-- ================================================
-- FLOWSTATE - COMPLETE DATABASE SETUP (V4)
-- ================================================
-- Bu dosya tüm veritabanı şemalarını, tabloları ve fonksiyonları içerir.
-- Sırasıyla:
-- 1. PRODUCTION_SCHEMA (Temel Tablolar ve Politikalar)
-- 2. AB_SCHEMA (A/B Testi Fonksiyonları)
-- 3. ADVANCED_ADMIN_SCHEMA (Gelişmiş Admin Özellikleri)
-- 4. ADMIN_ANALYTICS (Gelişmiş Analitik Fonksiyonları)
-- ================================================

-- ================================================
-- PART 1: PRODUCTION SCHEMA (BASE)
-- ================================================

-- Enable required extensions
create extension if not exists "uuid-ossp";

-- UTILITY FUNCTIONS
create or replace function update_updated_at()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- 1. PROFILES TABLE (User Identity)
create table if not exists public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  username text unique,
  display_name text,
  avatar_url text,
  is_banned boolean default false not null,
  ban_reason text,
  local_time text,
  user_timezone text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null
);

alter table public.profiles enable row level security;

-- RLS Policies
drop policy if exists "Public profiles are viewable by everyone" on public.profiles;
create policy "Public profiles are viewable by everyone"
  on public.profiles for select using (true);

drop policy if exists "Users can insert their own profile" on public.profiles;
create policy "Users can insert their own profile"
  on public.profiles for insert with check (auth.uid() = id);

drop policy if exists "Users can update own profile" on public.profiles;
create policy "Users can update own profile"
  on public.profiles for update using (auth.uid() = id);

-- Trigger for auto-update timestamp
drop trigger if exists update_profiles_timestamp on public.profiles;
create trigger update_profiles_timestamp
  before update on public.profiles
  for each row execute function update_updated_at();

-- Index for username lookups
create index if not exists profiles_username_idx on public.profiles (username);

-- 2. SCORES TABLE (Leaderboard - CORE)
create table if not exists public.scores (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  username text not null,
  date_key text not null,
  mode text default 'daily' not null,
  moves integer not null check (moves > 0),
  time_ms integer not null check (time_ms > 0),
  created_at timestamp with time zone default now() not null,
  -- Unique constraint: One score per user per day
  unique(user_id, date_key)
);

-- Add mode column if it doesn't exist (for existing tables)
do $$
begin
  if not exists (select 1 from information_schema.columns where table_schema = 'public' and table_name = 'scores' and column_name = 'mode') then
    alter table public.scores add column mode text default 'daily' not null;
  end if;
end $$;

alter table public.scores enable row level security;

-- RLS Policies
drop policy if exists "Scores are viewable by everyone" on public.scores;
create policy "Scores are viewable by everyone"
  on public.scores for select using (true);

drop policy if exists "Users can insert their own scores" on public.scores;
create policy "Users can insert their own scores"
  on public.scores for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update their own scores" on public.scores;
create policy "Users can update their own scores"
  on public.scores for update using (auth.uid() = user_id);

-- Performance indexes
create index if not exists scores_date_idx on public.scores (date_key);
create index if not exists scores_user_idx on public.scores (user_id);
create index if not exists scores_ranking_idx on public.scores (date_key, moves asc, time_ms asc);

-- 3. USER VISITS TABLE (Analytics)
create table if not exists public.user_visits (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  ip_address text,
  country text,
  city text,
  timezone text,
  user_agent text,
  platform text,
  browser text,
  os text,
  screen_width integer,
  screen_height integer,
  is_mobile boolean default false,
  referrer text,
  page_url text,
  local_time text,
  user_timezone text,
  created_at timestamp with time zone default now() not null
);

alter table public.user_visits enable row level security;

-- RLS Policies
drop policy if exists "Users can insert own visits" on public.user_visits;
create policy "Users can insert own visits"
  on public.user_visits for insert with check (auth.uid() = user_id);

drop policy if exists "Users can view own visits" on public.user_visits;
create policy "Users can view own visits"
  on public.user_visits for select using (auth.uid() = user_id);

-- Indexes
create index if not exists visits_user_idx on public.user_visits (user_id);
create index if not exists visits_created_idx on public.user_visits (created_at);
create index if not exists visits_country_idx on public.user_visits (country);

-- 4. ANALYTICS EVENTS TABLE
create table if not exists public.analytics_events (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  event_type text not null,
  event_data jsonb default '{}' not null,
  page_url text,
  local_time text,
  user_timezone text,
  created_at timestamp with time zone default now() not null
);

alter table public.analytics_events enable row level security;

-- RLS Policies
drop policy if exists "Users can insert own events" on public.analytics_events;
create policy "Users can insert own events"
  on public.analytics_events for insert with check (auth.uid() = user_id);

drop policy if exists "Users can view own events" on public.analytics_events;
create policy "Users can view own events"
  on public.analytics_events for select using (auth.uid() = user_id);

-- Indexes
create index if not exists events_user_idx on public.analytics_events (user_id);
create index if not exists events_type_idx on public.analytics_events (event_type);
create index if not exists events_created_idx on public.analytics_events (created_at);

-- 5. USER PROGRESS TABLE (XP, Level, Badges)
create table if not exists public.user_progress (
  id uuid references auth.users on delete cascade not null primary key,
  xp integer default 0 not null,
  level integer default 1 not null,
  total_wins integer default 0 not null,
  total_games integer default 0 not null,
  fastest_win_ms integer,
  consecutive_no_hint_wins integer default 0 not null,
  current_streak integer default 0 not null,
  max_streak integer default 0 not null,
  badges text[] default '{}' not null,
  last_played_at timestamp with time zone,
  local_time text,
  user_timezone text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null
);

alter table public.user_progress enable row level security;

-- RLS Policies
drop policy if exists "Users can view own progress" on public.user_progress;
create policy "Users can view own progress"
  on public.user_progress for select using (auth.uid() = id);

drop policy if exists "Users can insert own progress" on public.user_progress;
create policy "Users can insert own progress"
  on public.user_progress for insert with check (auth.uid() = id);

drop policy if exists "Users can update own progress" on public.user_progress;
create policy "Users can update own progress"
  on public.user_progress for update using (auth.uid() = id);

drop trigger if exists update_user_progress_timestamp on public.user_progress;
create trigger update_user_progress_timestamp
  before update on public.user_progress
  for each row execute function update_updated_at();

-- 6. USER ECONOMY TABLE (Coins)
create table if not exists public.user_economy (
  id uuid references auth.users on delete cascade not null primary key,
  coins integer default 0 not null check (coins >= 0),
  gems integer default 0 not null check (gems >= 0),
  total_earned integer default 0 not null,
  total_spent integer default 0 not null,
  unlocked_items text[] default '{}' not null,
  unlocked_themes text[] default '{"default"}' not null,
  active_theme text default 'default' not null,
  local_time text,
  user_timezone text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null
);

alter table public.user_economy enable row level security;

-- RLS Policies
drop policy if exists "Users can view own economy" on public.user_economy;
create policy "Users can view own economy"
  on public.user_economy for select using (auth.uid() = id);

drop policy if exists "Users can insert own economy" on public.user_economy;
create policy "Users can insert own economy"
  on public.user_economy for insert with check (auth.uid() = id);

drop policy if exists "Users can update own economy" on public.user_economy;
create policy "Users can update own economy"
  on public.user_economy for update using (auth.uid() = id);

drop trigger if exists update_user_economy_timestamp on public.user_economy;
create trigger update_user_economy_timestamp
  before update on public.user_economy
  for each row execute function update_updated_at();

-- 7. USER INVENTORY TABLE (Power-ups)
create table if not exists public.user_inventory (
  id uuid references auth.users on delete cascade not null primary key,
  hints integer default 3 not null check (hints >= 0),
  undos integer default 3 not null check (undos >= 0),
  freezes integer default 3 not null check (freezes >= 0),
  time_extensions integer default 0 not null check (time_extensions >= 0),
  coin_boosts integer default 0 not null check (coin_boosts >= 0),
  multipliers integer default 0 not null check (multipliers >= 0),
  local_time text,
  user_timezone text,
  created_at timestamp with time zone default now() not null,
  updated_at timestamp with time zone default now() not null
);

alter table public.user_inventory enable row level security;

-- RLS Policies
drop policy if exists "Users can view own inventory" on public.user_inventory;
create policy "Users can view own inventory"
  on public.user_inventory for select using (auth.uid() = id);

drop policy if exists "Users can insert own inventory" on public.user_inventory;
create policy "Users can insert own inventory"
  on public.user_inventory for insert with check (auth.uid() = id);

drop policy if exists "Users can update own inventory" on public.user_inventory;
create policy "Users can update own inventory"
  on public.user_inventory for update using (auth.uid() = id);

drop trigger if exists update_user_inventory_timestamp on public.user_inventory;
create trigger update_user_inventory_timestamp
  before update on public.user_inventory
  for each row execute function update_updated_at();

-- 8. CAMPAIGN PROGRESS TABLE
create table if not exists public.campaign_progress (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  level_id text not null,
  stars integer default 0 not null check (stars >= 0 and stars <= 3),
  moves integer,
  time_ms integer,
  completed_at timestamp with time zone default now() not null,
  unique(user_id, level_id)
);

alter table public.campaign_progress enable row level security;

-- RLS Policies
drop policy if exists "Users can view own campaign progress" on public.campaign_progress;
create policy "Users can view own campaign progress"
  on public.campaign_progress for select using (auth.uid() = user_id);

drop policy if exists "Users can insert own campaign progress" on public.campaign_progress;
create policy "Users can insert own campaign progress"
  on public.campaign_progress for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update own campaign progress" on public.campaign_progress;
create policy "Users can update own campaign progress"
  on public.campaign_progress for update using (auth.uid() = user_id);

create index if not exists campaign_user_idx on public.campaign_progress (user_id);
create index if not exists campaign_level_idx on public.campaign_progress (level_id);

-- 9. GAME SESSIONS TABLE (Detailed Analytics)
create table if not exists public.game_sessions (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  mode text not null,
  date_key text,
  level_id text,
  moves integer not null,
  time_ms integer not null,
  won boolean default false not null,
  used_hint boolean default false not null,
  powerups_used jsonb default '{}' not null,
  score integer default 0 not null,
  difficulty text default 'normal',
  local_time text,
  user_timezone text,
  created_at timestamp with time zone default now() not null
);

alter table public.game_sessions enable row level security;

-- RLS Policies
drop policy if exists "Users can view own sessions" on public.game_sessions;
create policy "Users can view own sessions"
  on public.game_sessions for select using (auth.uid() = user_id);

drop policy if exists "Users can insert own sessions" on public.game_sessions;
create policy "Users can insert own sessions"
  on public.game_sessions for insert with check (auth.uid() = user_id);

create index if not exists sessions_user_idx on public.game_sessions (user_id);
create index if not exists sessions_mode_idx on public.game_sessions (mode);
create index if not exists sessions_date_idx on public.game_sessions (date_key);
create index if not exists sessions_won_idx on public.game_sessions (won);
create index if not exists sessions_created_idx on public.game_sessions (created_at);

-- 10. ERROR LOGS TABLE
create table if not exists public.error_logs (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users,
  message text not null,
  stack text,
  component text,
  action text,
  context_data jsonb default '{}',
  severity text default 'error' check (severity in ('error', 'warning', 'info')),
  browser text,
  os text,
  platform text,
  is_mobile boolean default false,
  screen_width integer,
  screen_height integer,
  user_agent text,
  page_url text,
  created_at timestamp with time zone default now() not null
);

alter table public.error_logs enable row level security;

-- RLS Policies
drop policy if exists "Anyone can insert errors" on public.error_logs;
create policy "Anyone can insert errors"
  on public.error_logs for insert with check (true);

drop policy if exists "Users can view own errors" on public.error_logs;
create policy "Users can view own errors"
  on public.error_logs for select using (auth.uid() = user_id);

create index if not exists error_logs_user_idx on public.error_logs (user_id);
create index if not exists error_logs_created_idx on public.error_logs (created_at);
create index if not exists error_logs_severity_idx on public.error_logs (severity);

-- 11. REFERRAL SYSTEM TABLES
create table if not exists public.referral_codes (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null unique,
  code text not null unique,
  usage_count integer default 0 not null,
  created_at timestamp with time zone default now() not null
);

alter table public.referral_codes enable row level security;

drop policy if exists "Anyone can view referral codes" on public.referral_codes;
create policy "Anyone can view referral codes"
  on public.referral_codes for select using (true);

drop policy if exists "Users can create own referral code" on public.referral_codes;
create policy "Users can create own referral code"
  on public.referral_codes for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update own referral code" on public.referral_codes;
create policy "Users can update own referral code"
  on public.referral_codes for update using (auth.uid() = user_id);

create index if not exists referral_code_idx on public.referral_codes (code);

create table if not exists public.referral_usages (
  id bigint generated by default as identity primary key,
  referrer_id uuid references auth.users not null,
  referee_id uuid references auth.users not null,
  code text not null,
  claimed boolean default false not null,
  created_at timestamp with time zone default now() not null,
  unique(referee_id)
);

alter table public.referral_usages enable row level security;

drop policy if exists "Users can view referrals they made" on public.referral_usages;
create policy "Users can view referrals they made"
  on public.referral_usages for select using (auth.uid() = referrer_id);

drop policy if exists "Users can insert referral usage" on public.referral_usages;
create policy "Users can insert referral usage"
  on public.referral_usages for insert with check (auth.uid() = referee_id);

drop policy if exists "Referrers can update their referral claims" on public.referral_usages;
create policy "Referrers can update their referral claims"
  on public.referral_usages for update using (auth.uid() = referrer_id);

create index if not exists referral_referrer_idx on public.referral_usages (referrer_id);
create index if not exists referral_referee_idx on public.referral_usages (referee_id);

-- 12. A/B TESTING TABLES
create table if not exists public.experiment_assignments (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  experiment_id text not null,
  variant text not null,
  assigned_at timestamp with time zone default now() not null,
  unique(user_id, experiment_id)
);

alter table public.experiment_assignments enable row level security;

drop policy if exists "Users can view own assignments" on public.experiment_assignments;
create policy "Users can view own assignments"
  on public.experiment_assignments for select using (auth.uid() = user_id);

drop policy if exists "Users can insert own assignments" on public.experiment_assignments;
create policy "Users can insert own assignments"
  on public.experiment_assignments for insert with check (auth.uid() = user_id);

create index if not exists exp_assign_user_idx on public.experiment_assignments (user_id);
create index if not exists exp_assign_exp_idx on public.experiment_assignments (experiment_id);

create table if not exists public.experiment_events (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  experiment_id text not null,
  variant text not null,
  event_type text not null,
  event_data jsonb default '{}',
  created_at timestamp with time zone default now() not null
);

alter table public.experiment_events enable row level security;

drop policy if exists "Users can insert own experiment events" on public.experiment_events;
create policy "Users can insert own experiment events"
  on public.experiment_events for insert with check (auth.uid() = user_id);

drop policy if exists "Users can view own experiment events" on public.experiment_events;
create policy "Users can view own experiment events"
  on public.experiment_events for select using (auth.uid() = user_id);

create index if not exists exp_events_exp_idx on public.experiment_events (experiment_id);
create index if not exists exp_events_variant_idx on public.experiment_events (variant);
-- Missing index added from research
create index if not exists exp_events_type_idx on public.experiment_events (event_type);

-- 13. PURCHASE HISTORY TABLE
create table if not exists public.purchase_history (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade not null,
  item_id text not null,
  item_type text not null, -- powerup, theme, coin_pack, etc.
  quantity integer default 1 not null,
  price_coins integer default 0 not null,
  price_gems integer default 0 not null,
  price_real money, -- For real money purchases
  transaction_id text, -- External payment ID
  created_at timestamp with time zone default now() not null
);

alter table public.purchase_history enable row level security;

drop policy if exists "Users can view own purchases" on public.purchase_history;
create policy "Users can view own purchases"
  on public.purchase_history for select using (auth.uid() = user_id);

drop policy if exists "Users can insert own purchases" on public.purchase_history;
create policy "Users can insert own purchases"
  on public.purchase_history for insert with check (auth.uid() = user_id);

create index if not exists purchases_user_idx on public.purchase_history (user_id);
create index if not exists purchases_created_idx on public.purchase_history (created_at);

-- HELPER FUNCTIONS
create or replace function get_user_rank(p_user_id uuid, p_date_key text)
returns integer as $$
declare
  user_rank integer;
begin
  select rank into user_rank
  from (
    select user_id, rank() over (order by moves asc, time_ms asc) as rank
    from public.scores
    where date_key = p_date_key
  ) ranked
  where user_id = p_user_id;
  
  return coalesce(user_rank, 0);
end;
$$ language plpgsql security definer;

create or replace function get_daily_stats(days_back integer default 7)
returns table (
  stat_date date,
  unique_users bigint,
  total_visits bigint,
  total_games bigint,
  total_wins bigint
)
language sql
security definer
as $$
  with date_series as (
    select generate_series(
      current_date - (days_back - 1),
      current_date,
      '1 day'::interval
    )::date as stat_date
  )
  select 
    ds.stat_date,
    coalesce(count(distinct uv.user_id), 0) as unique_users,
    coalesce(count(uv.id), 0) as total_visits,
    coalesce((select count(*) from public.game_sessions gs where date(gs.created_at) = ds.stat_date), 0) as total_games,
    coalesce((select count(*) from public.game_sessions gs where date(gs.created_at) = ds.stat_date and gs.won = true), 0) as total_wins
  from date_series ds
  left join public.user_visits uv on date(uv.created_at) = ds.stat_date
  group by ds.stat_date
  order by ds.stat_date desc;
$$;

create or replace function get_country_stats()
returns table (
  country text,
  visit_count bigint,
  unique_users bigint
)
language sql
security definer
as $$
  select 
    coalesce(country, 'Unknown') as country,
    count(*) as visit_count,
    count(distinct user_id) as unique_users
  from public.user_visits
  where created_at > now() - interval '30 days'
  group by country
  order by visit_count desc
  limit 20;
$$;

create or replace function get_referral_stats(p_user_id uuid)
returns json
language sql
security definer
as $$
  select json_build_object(
    'totalReferrals', coalesce((
      select usage_count from public.referral_codes where user_id = p_user_id
    ), 0),
    'referralCode', (
      select code from public.referral_codes where user_id = p_user_id
    ),
    'unclaimedCount', coalesce((
      select count(*) from public.referral_usages 
      where referrer_id = p_user_id and claimed = false
    ), 0)
  );
$$;

-- ================================================
-- PART 2: AB TESTING FUNCTIONS (Expanded)
-- ================================================

-- Get variant distribution for an experiment
create or replace function get_experiment_distribution(p_experiment_id text)
returns table (
  variant text,
  user_count bigint,
  percentage numeric
)
language sql
security definer
as $$
  with total as (
    select count(*) as cnt from public.experiment_assignments 
    where experiment_id = p_experiment_id
  )
  select 
    variant,
    count(*) as user_count,
    round((count(*)::numeric / nullif((select cnt from total), 0)) * 100, 2) as percentage
  from public.experiment_assignments
  where experiment_id = p_experiment_id
  group by variant
  order by variant;
$$;

-- Get conversion rate for an experiment
create or replace function get_experiment_conversions(
  p_experiment_id text, 
  p_conversion_event text
)
returns table (
  variant text,
  total_users bigint,
  converted_users bigint,
  conversion_rate numeric
)
language sql
security definer
as $$
  with assignments as (
    select user_id, variant
    from public.experiment_assignments
    where experiment_id = p_experiment_id
  ),
  conversions as (
    select distinct user_id
    from public.experiment_events
    where experiment_id = p_experiment_id 
    and event_type = p_conversion_event
  )
  select 
    a.variant,
    count(distinct a.user_id) as total_users,
    count(distinct c.user_id) as converted_users,
    round(
      (count(distinct c.user_id)::numeric / nullif(count(distinct a.user_id), 0)) * 100, 
      2
    ) as conversion_rate
  from assignments a
  left join conversions c on a.user_id = c.user_id
  group by a.variant
  order by a.variant;
$$;

-- ================================================
-- PART 3: ADVANCED ADMIN FEATURES
-- ================================================

-- RETENTION RATE FUNCTION
create or replace function get_retention_stats()
returns json
language plpgsql
security definer
as $$
declare
  total_users integer;
  day1_retained integer;
  day7_retained integer;
  day30_retained integer;
begin
  -- Total users with at least one visit
  select count(distinct user_id) into total_users
  from public.user_visits
  where created_at < now() - interval '1 day';
  
  -- Day 1 retention
  select count(distinct v1.user_id) into day1_retained
  from public.user_visits v1
  where exists (
    select 1 from public.user_visits v2
    where v2.user_id = v1.user_id
    and v2.created_at > v1.created_at + interval '1 day'
    and v2.created_at < v1.created_at + interval '2 days'
  );
  
  -- Day 7 retention
  select count(distinct v1.user_id) into day7_retained
  from public.user_visits v1
  where exists (
    select 1 from public.user_visits v2
    where v2.user_id = v1.user_id
    and v2.created_at > v1.created_at + interval '7 days'
    and v2.created_at < v1.created_at + interval '8 days'
  );
  
  -- Day 30 retention
  select count(distinct v1.user_id) into day30_retained
  from public.user_visits v1
  where exists (
    select 1 from public.user_visits v2
    where v2.user_id = v1.user_id
    and v2.created_at > v1.created_at + interval '30 days'
    and v2.created_at < v1.created_at + interval '31 days'
  );
  
  return json_build_object(
    'totalUsers', total_users,
    'day1Retention', case when total_users > 0 then round((day1_retained::numeric / total_users) * 100, 1) else 0 end,
    'day7Retention', case when total_users > 0 then round((day7_retained::numeric / total_users) * 100, 1) else 0 end,
    'day30Retention', case when total_users > 0 then round((day30_retained::numeric / total_users) * 100, 1) else 0 end,
    'day1Count', day1_retained,
    'day7Count', day7_retained,
    'day30Count', day30_retained
  );
end;
$$;

-- SESSION DURATION FUNCTION
create or replace function get_session_stats()
returns json
language sql
security definer
as $$
  select json_build_object(
    'totalSessions', count(*),
    'avgDurationSeconds', coalesce(round(avg(time_ms) / 1000), 0),
    'avgDurationMinutes', coalesce(round(avg(time_ms) / 60000, 1), 0),
    'maxDurationMinutes', coalesce(round(max(time_ms) / 60000, 1), 0),
    'avgMovesPerGame', coalesce(round(avg(moves)), 0),
    'winRate', coalesce(round((sum(case when won then 1 else 0 end)::numeric / nullif(count(*), 0)) * 100, 1), 0)
  )
  from public.game_sessions
  where created_at > now() - interval '7 days';
$$;

-- FUNNEL ANALYSIS FUNCTION
create or replace function get_funnel_stats(days_back integer default 7)
returns json
language plpgsql
security definer
as $$
declare
  total_visits integer;
  users_with_game integer;
  users_with_win integer;
  users_with_purchase integer;
begin
  -- Stage 1: Total unique visitors
  select count(distinct user_id) into total_visits
  from public.user_visits
  where created_at > now() - (days_back || ' days')::interval;
  
  -- Stage 2: Users who played at least one game
  select count(distinct user_id) into users_with_game
  from public.game_sessions
  where created_at > now() - (days_back || ' days')::interval;
  
  -- Stage 3: Users who won at least once
  select count(distinct user_id) into users_with_win
  from public.game_sessions
  where won = true
  and created_at > now() - (days_back || ' days')::interval;
  
  -- Stage 4: Users who made a purchase
  select count(distinct user_id) into users_with_purchase
  from public.analytics_events
  where event_type = 'shop_purchase'
  and created_at > now() - (days_back || ' days')::interval;
  
  return json_build_object(
    'stages', json_build_array(
      json_build_object('name', 'Ziyaret', 'count', total_visits, 'rate', 100),
      json_build_object('name', 'Oyun', 'count', users_with_game, 
        'rate', case when total_visits > 0 then round((users_with_game::numeric / total_visits) * 100, 1) else 0 end),
      json_build_object('name', 'Kazanma', 'count', users_with_win,
        'rate', case when total_visits > 0 then round((users_with_win::numeric / total_visits) * 100, 1) else 0 end),
      json_build_object('name', 'Satın Alma', 'count', users_with_purchase,
        'rate', case when total_visits > 0 then round((users_with_purchase::numeric / total_visits) * 100, 1) else 0 end)
    )
  );
end;
$$;

-- A/B TEST RESULTS FUNCTION
create or replace function get_ab_test_results()
returns json
language sql
security definer
as $$
  select coalesce(json_agg(row_to_json(t)), '[]'::json)
  from (
    select 
      ea.experiment_id,
      ea.variant,
      count(distinct ea.user_id) as user_count,
      count(distinct ee.id) as event_count,
      round(count(distinct ee.id)::numeric / nullif(count(distinct ea.user_id), 0), 2) as events_per_user
    from public.experiment_assignments ea
    left join public.experiment_events ee 
      on ea.user_id = ee.user_id 
      and ea.experiment_id = ee.experiment_id
    group by ea.experiment_id, ea.variant
    order by ea.experiment_id, ea.variant
  ) t;
$$;

-- REAL-TIME ACTIVE USERS FUNCTION
create or replace function get_realtime_stats()
returns json
language sql
security definer
as $$
  select json_build_object(
    'activeNow', (
      select count(distinct user_id)
      from public.user_visits
      where created_at > now() - interval '5 minutes'
    ),
    'activeLast15Min', (
      select count(distinct user_id)
      from public.user_visits
      where created_at > now() - interval '15 minutes'
    ),
    'activeLast1Hour', (
      select count(distinct user_id)
      from public.user_visits
      where created_at > now() - interval '1 hour'
    ),
    'gamesLast1Hour', (
      select count(*)
      from public.game_sessions
      where created_at > now() - interval '1 hour'
    )
  );
$$;

-- CUSTOM DATE RANGE STATS FUNCTION
create or replace function get_stats_for_range(
  start_date timestamp with time zone,
  end_date timestamp with time zone
)
returns json
language sql
security definer
as $$
  select json_build_object(
    'uniqueUsers', (
      select count(distinct user_id)
      from public.user_visits
      where created_at between start_date and end_date
    ),
    'totalVisits', (
      select count(*)
      from public.user_visits
      where created_at between start_date and end_date
    ),
    'totalGames', (
      select count(*)
      from public.game_sessions
      where created_at between start_date and end_date
    ),
    'totalWins', (
      select count(*)
      from public.game_sessions
      where won = true
      and created_at between start_date and end_date
    ),
    'avgMoves', (
      select coalesce(round(avg(moves)), 0)
      from public.game_sessions
      where created_at between start_date and end_date
    )
  );
$$;

-- USER BAN/WARN TRACKING TABLE
create table if not exists public.user_moderation (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  action_type text not null check (action_type in ('ban', 'warn', 'reset_score', 'unban')),
  reason text,
  admin_id uuid,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index if not exists user_mod_user_idx on public.user_moderation (user_id);

-- ADMIN BROADCAST TABLE
create table if not exists public.admin_broadcasts (
  id bigint generated by default as identity primary key,
  title text not null,
  body text not null,
  target_type text default 'all' check (target_type in ('all', 'active', 'inactive')),
  sent_by uuid,
  sent_at timestamp with time zone default timezone('utc'::text, now()) not null,
  send_count integer default 0
);

-- ================================================
-- PART 4: ADMIN ANALYTICS - ENHANCED
-- ================================================

-- REVENUE ANALYTICS
create or replace function get_revenue_stats(days_back integer default 30)
returns json
language sql
security definer
as $$
  select json_build_object(
    'dailyRevenue', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          date(created_at) as date,
          count(*) as transactions,
          coalesce(sum(price_coins), 0) as coin_revenue,
          coalesce(sum(price_gems), 0) as gem_revenue,
          coalesce(sum(price_real::numeric), 0) as real_revenue
        from public.purchase_history
        where created_at > now() - (days_back || ' days')::interval
        group by date(created_at)
        order by date desc
      ) t
    ),
    'totalRevenue', (
      select json_build_object(
        'coins', coalesce(sum(price_coins), 0),
        'gems', coalesce(sum(price_gems), 0),
        'real', coalesce(sum(price_real::numeric), 0),
        'transactions', count(*)
      )
      from public.purchase_history
      where created_at > now() - (days_back || ' days')::interval
    ),
    'topItems', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          item_id,
          item_type,
          count(*) as purchase_count,
          sum(quantity) as total_quantity
        from public.purchase_history
        where created_at > now() - (days_back || ' days')::interval
        group by item_id, item_type
        order by purchase_count desc
        limit 10
      ) t
    ),
    'payingUsers', (
      select count(distinct user_id)
      from public.purchase_history
      where price_real > 0::money
      and created_at > now() - (days_back || ' days')::interval
    )
  );
$$;

-- GROWTH METRICS
create or replace function get_growth_metrics()
returns json
language sql
security definer
as $$
  select json_build_object(
    'dau', (
      select count(distinct user_id) from public.user_visits where date(created_at) = current_date
    ),
    'dauYesterday', (
      select count(distinct user_id) from public.user_visits where date(created_at) = current_date - 1
    ),
    'wau', (
      select count(distinct user_id) from public.user_visits where created_at > now() - interval '7 days'
    ),
    'wauLastWeek', (
      select count(distinct user_id) from public.user_visits where created_at between now() - interval '14 days' and now() - interval '7 days'
    ),
    'mau', (
      select count(distinct user_id) from public.user_visits where created_at > now() - interval '30 days'
    ),
    'mauLastMonth', (
      select count(distinct user_id) from public.user_visits where created_at between now() - interval '60 days' and now() - interval '30 days'
    ),
    'newUsersToday', (
      select count(*) from public.profiles where date(created_at) = current_date
    ),
    'newUsersThisWeek', (
      select count(*) from public.profiles where created_at > now() - interval '7 days'
    ),
    'newUsersThisMonth', (
      select count(*) from public.profiles where created_at > now() - interval '30 days'
    ),
    'totalUsers', (
      select count(*) from public.profiles
    ),
    'dauTrend', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          date(created_at) as date,
          count(distinct user_id) as dau
        from public.user_visits
        where created_at > now() - interval '30 days'
        group by date(created_at)
        order by date desc
      ) t
    )
  );
$$;

-- LEADERBOARD INSIGHTS
create or replace function get_leaderboard_insights(days_back integer default 7)
returns json
language sql
security definer
as $$
  select json_build_object(
    'topPlayers', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          p.username,
          up.level,
          up.total_wins,
          up.xp,
          up.current_streak,
          up.max_streak,
          count(gs.id) as games_this_week
        from public.profiles p
        join public.user_progress up on p.id = up.id
        left join public.game_sessions gs on p.id = gs.user_id 
          and gs.created_at > now() - (days_back || ' days')::interval
        group by p.username, up.level, up.total_wins, up.xp, up.current_streak, up.max_streak
        order by up.total_wins desc
        limit 20
      ) t
    ),
    'topByMode', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          s.mode,
          p.username,
          min(s.moves) as best_moves,
          min(s.time_ms) as best_time
        from public.scores s
        join public.profiles p on s.user_id = p.id
        where s.created_at > now() - (days_back || ' days')::interval
        group by s.mode, p.username
        order by s.mode, best_moves asc, best_time asc
      ) t
    ),
    'recordBreakers', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          p.username,
          up.fastest_win_ms,
          up.max_streak
        from public.user_progress up
        join public.profiles p on up.id = p.id
        where up.fastest_win_ms is not null
        order by up.fastest_win_ms asc
        limit 10
      ) t
    ),
    'highestLevel', (
      select json_build_object(
        'maxLevel', max(level),
        'maxXP', max(xp),
        'avgLevel', round(avg(level), 1)
      )
      from public.user_progress
    )
  );
$$;

-- GAME MODE STATISTICS
create or replace function get_game_mode_stats(days_back integer default 30)
returns json
language sql
security definer
as $$
  select json_build_object(
    'modeDistribution', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          mode,
          count(*) as total_games,
          count(distinct user_id) as unique_players,
          round(count(*)::numeric / nullif(sum(count(*)) over (), 0) * 100, 1) as percentage,
          round(avg(time_ms) / 1000, 1) as avg_duration_sec,
          round(avg(moves), 1) as avg_moves,
          round(sum(case when won then 1 else 0 end)::numeric / nullif(count(*), 0) * 100, 1) as win_rate
        from public.game_sessions
        where created_at > now() - (days_back || ' days')::interval
        group by mode
        order by total_games desc
      ) t
    ),
    'modeTrend', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          date(created_at) as date,
          mode,
          count(*) as games
        from public.game_sessions
        where created_at > now() - interval '14 days'
        group by date(created_at), mode
        order by date desc, mode
      ) t
    ),
    'modeRetention', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          mode,
          count(distinct case when game_count > 1 then user_id end) as returning_players,
          count(distinct user_id) as total_players
        from (
          select user_id, mode, count(*) as game_count
          from public.game_sessions
          where created_at > now() - (days_back || ' days')::interval
          group by user_id, mode
        ) sub
        group by mode
      ) t
    )
  );
$$;

-- PEAK HOURS STATS
create or replace function get_peak_hours_stats(days_back integer default 7)
returns json
language sql
security definer
as $$
  select json_build_object(
    'hourlyDistribution', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          extract(hour from created_at)::integer as hour,
          count(*) as visits,
          count(distinct user_id) as unique_users
        from public.user_visits
        where created_at > now() - (days_back || ' days')::interval
        group by extract(hour from created_at)
        order by hour
      ) t
    ),
    'dayOfWeekDistribution', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          extract(dow from created_at)::integer as day_of_week,
          count(*) as visits,
          count(distinct user_id) as unique_users
        from public.user_visits
        where created_at > now() - (days_back || ' days')::interval
        group by extract(dow from created_at)
        order by day_of_week
      ) t
    ),
    'heatmapData', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          extract(dow from created_at)::integer as day,
          extract(hour from created_at)::integer as hour,
          count(*) as activity
        from public.user_visits
        where created_at > now() - (days_back || ' days')::interval
        group by extract(dow from created_at), extract(hour from created_at)
        order by day, hour
      ) t
    ),
    'peakHour', (
      select json_build_object(
        'hour', extract(hour from created_at)::integer,
        'visits', count(*)
      )
      from public.user_visits
      where created_at > now() - (days_back || ' days')::interval
      group by extract(hour from created_at)
      order by count(*) desc
      limit 1
    ),
    'peakDay', (
      select json_build_object(
        'day', extract(dow from created_at)::integer,
        'visits', count(*)
      )
      from public.user_visits
      where created_at > now() - (days_back || ' days')::interval
      group by extract(dow from created_at)
      order by count(*) desc
      limit 1
    )
  );
$$;

-- NOTIFICATION LOGS & STATS
create table if not exists public.notification_logs (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users on delete cascade,
  notification_type text not null,
  title text not null,
  body text,
  sent_at timestamp with time zone default now() not null,
  opened boolean default false not null,
  opened_at timestamp with time zone,
  broadcast_id bigint references public.admin_broadcasts(id)
);

alter table public.notification_logs enable row level security;

drop policy if exists "Users can view own notifications" on public.notification_logs;
create policy "Users can view own notifications"
  on public.notification_logs for select using (auth.uid() = user_id);

drop policy if exists "Users can insert own notifications" on public.notification_logs;
create policy "Users can insert own notifications"
  on public.notification_logs for insert with check (auth.uid() = user_id);

drop policy if exists "Users can update own notifications" on public.notification_logs;
create policy "Users can update own notifications"
  on public.notification_logs for update using (auth.uid() = user_id);

create index if not exists notif_user_idx on public.notification_logs (user_id);
create index if not exists notif_type_idx on public.notification_logs (notification_type);
create index if not exists notif_sent_idx on public.notification_logs (sent_at);

create or replace function get_notification_stats(days_back integer default 30)
returns json
language sql
security definer
as $$
  select json_build_object(
    'totalSent', (
      select count(*) from public.notification_logs
      where sent_at > now() - (days_back || ' days')::interval
    ),
    'totalOpened', (
      select count(*) from public.notification_logs
      where opened = true
      and sent_at > now() - (days_back || ' days')::interval
    ),
    'openRate', (
      select round(
        (count(*) filter (where opened = true))::numeric / 
        nullif(count(*), 0) * 100, 1
      )
      from public.notification_logs
      where sent_at > now() - (days_back || ' days')::interval
    ),
    'byType', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          notification_type,
          count(*) as sent,
          count(*) filter (where opened) as opened,
          round(count(*) filter (where opened)::numeric / nullif(count(*), 0) * 100, 1) as open_rate
        from public.notification_logs
        where sent_at > now() - (days_back || ' days')::interval
        group by notification_type
        order by sent desc
      ) t
    ),
    'dailyTrend', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          date(sent_at) as date,
          count(*) as sent,
          count(*) filter (where opened) as opened
        from public.notification_logs
        where sent_at > now() - (days_back || ' days')::interval
        group by date(sent_at)
        order by date desc
      ) t
    ),
    'broadcastStats', (
      select coalesce(json_agg(row_to_json(t)), '[]'::json)
      from (
        select 
          ab.id,
          ab.title,
          ab.sent_at,
          ab.send_count,
          count(nl.id) as delivered,
          count(*) filter (where nl.opened) as opened
        from public.admin_broadcasts ab
        left join public.notification_logs nl on ab.id = nl.broadcast_id
        where ab.sent_at > now() - (days_back || ' days')::interval
        group by ab.id, ab.title, ab.sent_at, ab.send_count
        order by ab.sent_at desc
        limit 10
      ) t
    ),
    'avgTimeToOpen', (
      select round(avg(extract(epoch from (opened_at - sent_at)) / 60), 1)
      from public.notification_logs
      where opened = true
      and opened_at is not null
      and sent_at > now() - (days_back || ' days')::interval
    )
  );
$$;

-- DASHBOARD SUMMARY (ALL-IN-ONE)
create or replace function get_dashboard_summary()
returns json
language sql
security definer
as $$
  select json_build_object(
    'realtime', (
      select json_build_object(
        'activeNow', (select count(distinct user_id) from public.user_visits where created_at > now() - interval '5 minutes'),
        'gamesNow', (select count(*) from public.game_sessions where created_at > now() - interval '5 minutes')
      )
    ),
    'today', (
      select json_build_object(
        'visits', (select count(*) from public.user_visits where date(created_at) = current_date),
        'uniqueUsers', (select count(distinct user_id) from public.user_visits where date(created_at) = current_date),
        'games', (select count(*) from public.game_sessions where date(created_at) = current_date),
        'wins', (select count(*) from public.game_sessions where date(created_at) = current_date and won = true),
        'newUsers', (select count(*) from public.profiles where date(created_at) = current_date),
        'purchases', (select count(*) from public.purchase_history where date(created_at) = current_date)
      )
    ),
    'totals', (
      select json_build_object(
        'users', (select count(*) from public.profiles),
        'games', (select count(*) from public.game_sessions),
        'wins', (select count(*) from public.game_sessions where won = true),
        'purchases', (select count(*) from public.purchase_history)
      )
    ),
    'growth', (
      select json_build_object(
        'dau', (select count(distinct user_id) from public.user_visits where date(created_at) = current_date),
        'wau', (select count(distinct user_id) from public.user_visits where created_at > now() - interval '7 days'),
        'mau', (select count(distinct user_id) from public.user_visits where created_at > now() - interval '30 days')
      )
    )
  );
$$;

-- ================================================
-- FINAL CHECK & CLEANUP
-- ================================================
-- Grant permissions to service role if needed (handled by policies usually)
-- ================================================
